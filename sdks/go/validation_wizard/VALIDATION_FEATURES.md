# 信任链验证和综合验证功能说明

## 概述

本文档详细说明验证向导中的两个高级验证功能：**信任链验证**和**综合验证**。

---

## 5. 🔗 信任链验证（Trust Chain Validation）

### 功能说明

验证从**根证书到当前设备**的完整加密签名链，确保Token的每一层签名都是有效且可信的。

### 验证层级

```
根密钥（Root Key）
    ↓ 签名
产品公钥（Product Public Key）
    ↓ 签名
Token签名（Token Signature）
    ↓ 绑定
设备ID（Device ID）
```

### 执行步骤

使用向导中的**选项5：🔗 信任链验证**

#### 步骤1：选择Token来源

```
💡 请选择令牌来源:
0. 使用当前激活的令牌

📄 或从以下文件加载令牌:
1. token_activated_RSA-2026-020-8WFMPF_20260114122835.txt
2. token_state_RSA-2026-020-8WFMPF_idx1_20260114130000.txt

请选择 (0-2):
```

- **选项0**：使用当前已在内存中激活的token
- **选项1-N**：从文件导入token进行验证

#### 步骤2：系统自动执行4项检查

```
📋 开始验证信任链...

🔍 [1/4] 验证令牌签名（根密钥 → 产品公钥 → 令牌）
   ✅ 通过: 令牌签名有效，信任链完整

🔍 [2/4] 验证设备状态
   ✅ 通过: 设备状态正常 (状态码: 0)

🔍 [3/4] 验证令牌持有者与当前设备匹配
   ✅ 通过: 令牌持有者与当前设备匹配
   📱 设备ID: 465995af0f2c75a3933572ccfc5aa3472a63402951f8b13d16ae6c7effb4b5db

🔍 [4/4] 检查令牌详细信息
   ✅ 通过: 令牌信息完整
   🎫 令牌ID: 23168e50a7c148601646e33947219be1
   📝 许可证代码: RSA-2026-020-8WFMPF
   📱 应用ID: dev
   📅 颁发时间: 2026-01-14 12:15:50
   ⏰ 到期时间: 永不过期

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 验证结果: 4/4 项检查通过
🎉 信任链验证完全通过！令牌可信且安全
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 验证项说明

#### [1/4] 令牌签名验证

**验证内容**：
- Token的 `signature` 字段是否有效
- 产品公钥是否能正确验证签名
- 根证书签名链是否完整

**技术细节**：
```
Token.signature = RSA_Sign(LicensePrivateKey, TokenData)
验证: RSA_Verify(ProductPublicKey, Token.signature, TokenData)
```

**通过标准**：
- ✅ 签名验证成功
- ✅ 产品公钥有效
- ✅ 根证书链完整

**失败原因**：
- ❌ Token被篡改
- ❌ 产品公钥错误
- ❌ 签名算法不匹配

#### [2/4] 设备状态验证

**验证内容**：
- 客户端内部状态机
- P2P网络状态
- 连接健康度

**状态码含义**：
- `0` - Idle（空闲）
- `1` - Discovering（发现中）
- `2` - Electing（选举中）
- `3` - Coordinator（协调者）
- `4` - Follower（跟随者）

#### [3/4] 设备绑定匹配

**验证内容**：
- Token中的 `HolderDeviceID` 字段
- 当前设备的实际设备ID
- 两者是否一致

**设备ID生成**：
```
DeviceID = SHA256(MAC地址 + CPU序列号 + 硬盘序列号)
```

**匹配结果**：
- ✅ **匹配**：Token绑定到当前设备
- ⚠️ **不匹配**：Token从其他设备导入

#### [4/4] 令牌详细信息

**检查项目**：
- TokenID是否完整
- LicenseCode是否有效
- 颁发时间和到期时间是否合理
- 所有必需字段是否存在

### 使用场景

| 场景 | 说明 |
|------|------|
| **安全审计** | 定期检查Token签名链完整性 |
| **跨设备验证** | 确认导入的Token来源可信 |
| **合规检查** | 验证Token符合安全标准 |
| **防篡改** | 检测Token是否被修改 |
| **设备验证** | 确认Token绑定关系 |

### 注意事项

1. **只读操作**：不会修改Token或写入任何数据
2. **离线可用**：完全离线验证，无需网络
3. **产品公钥**：需要正确的产品公钥文件
4. **设备绑定**：跨设备导入的Token会显示设备不匹配警告

---

## 6. 🎯 综合验证（Comprehensive Validation）

### 功能说明

**全面测试SDK的所有核心功能**，从激活到记账的完整流程，确保许可证系统工作正常。

### 验证流程

```
激活状态检查 → 令牌签名验证 → 设备状态检查
    → 令牌信息检查 → 记账功能测试（实际写入）
```

### 执行步骤

使用向导中的**选项6：🎯 综合验证**

#### 步骤1：选择Token来源

```
💡 请选择令牌来源:
0. 使用当前激活的令牌

📄 或从以下文件加载令牌:
1. token_activated_RSA-2026-020-8WFMPF_20260114122835.txt
2. token_state_RSA-2026-020-8WFMPF_idx1_20260114130000.txt

请选择 (0-2):
```

#### 步骤2：系统自动执行5项检查

```
📋 执行综合验证流程...

✅ 检查1通过: 许可证已激活
✅ 检查2通过: 令牌验证成功
✅ 检查3通过: 设备状态正常 (状态码: 0)
✅ 检查4通过: 令牌信息完整 (ID: 23168e50a7c14860...)
✅ 检查5通过: 记账功能正常
   📦 状态变更后的新Token已生成
   Token长度: 1928 字符
   💾 已保存到: token_state_RSA-2026-020-8WFMPF_idx2_20260114140000.txt

📊 综合验证结果:
   总检查项: 5
   通过项目: 5
   成功率: 100.0%
🎉 所有检查均通过！系统运行正常
```

### 验证项说明

#### 检查1：激活状态

**API调用**：`IsActivated()`

**验证内容**：
- 客户端是否处于激活状态
- 激活标志是否正确设置

**结果**：
- ✅ 许可证已激活
- ⚠️ 许可证未激活

#### 检查2：令牌验证

**API调用**：`OfflineVerifyCurrentToken()`

**验证内容**：
- Token签名有效性
- 加密算法正确性
- 证书链完整性

**结果**：
- ✅ 令牌验证成功
- ❌ 令牌验证失败（含错误信息）

#### 检查3：设备状态

**API调用**：`GetDeviceState()`

**验证内容**：
- P2P网络状态
- 客户端状态机
- 连接健康度

**结果**：
- ✅ 设备状态正常（显示状态码）
- ❌ 设备状态查询失败

#### 检查4：令牌信息

**API调用**：`GetCurrentToken()`

**验证内容**：
- Token对象是否存在
- TokenID是否有效
- 数据结构是否完整

**结果**：
- ✅ 令牌信息完整（显示TokenID前16位）
- ❌ 令牌信息查询失败
- ⚠️ 无令牌信息（未激活）

#### 检查5：记账功能测试 ⭐

**API调用**：`RecordUsage()`

**验证内容**：
- **实际写入**测试数据到usage_chain
- 状态索引是否正确递增
- 新Token是否正确生成

**测试数据**：
```json
{
  "action": "comprehensive_test",
  "timestamp": 1234567890
}
```

**副作用**：
- ✅ 生成新的state token
- ✅ state_index递增
- ✅ 保存新token到文件

**结果**：
- ✅ 记账功能正常（生成新token）
- ❌ 记账功能测试失败（含错误信息）

### 使用场景

| 场景 | 说明 |
|------|------|
| **首次集成** | 验证SDK是否正确配置 |
| **部署前测试** | 确保生产环境可用 |
| **功能测试** | 端到端功能验证 |
| **健康检查** | 定期检查系统状态 |
| **故障排查** | 快速定位问题所在 |
| **压力测试** | 验证记账功能稳定性 |

### 注意事项

1. **会修改数据**：检查5会实际写入记账数据
2. **生成新Token**：每次运行都会递增state_index
3. **使用测试数据**：记账内容是固定的测试数据
4. **文件自动保存**：新token自动保存到当前目录

---

## 两者对比

### 功能对比表

| 对比项 | 信任链验证 | 综合验证 |
|--------|-----------|----------|
| **主要目的** | 验证签名链完整性 | 测试所有功能 |
| **检查项数量** | 4项 | 5项 |
| **是否修改数据** | ❌ 只读 | ✅ 写入记账数据 |
| **是否生成Token** | ❌ 否 | ✅ 生成state token |
| **离线可用** | ✅ 完全离线 | ✅ 离线模式 |
| **执行时间** | 快速（秒级） | 稍慢（包含写入） |
| **适用场景** | 安全审计 | 功能测试 |
| **副作用** | 无 | state_index递增 |

### 选择建议

#### 何时使用信任链验证？

```
✅ 怀疑Token被篡改
✅ 验证Token来源可信
✅ 定期安全审计
✅ 不想改变数据
✅ 快速验证签名
```

#### 何时使用综合验证？

```
✅ 首次集成SDK
✅ 部署前全面测试
✅ 验证所有功能可用
✅ 测试记账功能
✅ 故障排查定位
✅ 生成测试数据
```

---

## 典型工作流

### 场景1：首次部署验证

```bash
1. 选项1：激活令牌（首次激活）
   ↓
2. 选项6：综合验证（全功能测试）
   ↓
3. 选项5：信任链验证（安全检查）
   ↓
4. 准备生产环境
```

### 场景2：日常安全审计

```bash
1. 选项5：信任链验证
   - 使用生产环境的token文件
   - 验证签名链完整性
   - 检查设备绑定状态
   ↓
2. 生成审计报告
```

### 场景3：故障排查

```bash
用户报告："记账功能不工作"
   ↓
1. 选项6：综合验证
   ↓
2. 查看哪个检查失败：
   - 检查1失败 → 激活问题
   - 检查2失败 → 签名问题
   - 检查3失败 → 网络/设备问题
   - 检查4失败 → Token损坏
   - 检查5失败 → 记账API问题
   ↓
3. 针对性修复
```

### 场景4：跨设备Token迁移

```bash
1. 从设备A导出activated token
   ↓
2. 在设备B运行选项5：信任链验证
   - 检查签名有效性
   - 预期：设备绑定不匹配警告
   ↓
3. 如果签名有效，继续使用
4. 如果签名无效，拒绝导入
```

---

## 技术细节

### SDK API映射

#### 信任链验证调用的API

```go
// [1/4] 令牌签名验证
client.OfflineVerifyCurrentToken()

// [2/4] 设备状态
client.GetDeviceState()

// [3/4] 设备绑定匹配
client.GetCurrentToken()     // 获取HolderDeviceID
client.GetDeviceID()         // 获取当前设备ID

// [4/4] 令牌详细信息
client.GetStatus()           // 获取完整状态
```

#### 综合验证调用的API

```go
// 检查1
client.IsActivated()

// 检查2
client.OfflineVerifyCurrentToken()

// 检查3
client.GetDeviceState()

// 检查4
client.GetCurrentToken()

// 检查5
client.RecordUsage(testData)               // ⚠️ 会写入数据
client.ExportStateChangedTokenEncrypted()  // 导出新token
```

### Token文件支持

两个功能都支持从以下类型的token文件导入：

1. **token_activated_*.txt** - 首次激活生成的token
2. **token_state_*_idx*.txt** - 记账后生成的state token

导入过程：
```
读取文件 → ImportToken → ActivateBindDevice → 执行验证
```

---

## 常见问题

### Q1: 信任链验证会修改Token吗？

**A**: ❌ 不会。信任链验证是**完全只读**的操作，只检查不修改。

### Q2: 综合验证每次都会生成新Token吗？

**A**: ✅ 是的。检查5（记账功能测试）会实际写入数据，导致：
- state_index递增
- 生成新的state token
- 保存到文件

### Q3: 可以用加密Token进行验证吗？

**A**: ✅ 可以，但会先执行首次激活。两个功能都支持：
- 加密Token（encrypted）→ 首次激活 → 验证
- 已激活Token（activated/state）→ 恢复状态 → 验证

### Q4: 验证失败怎么办？

**A**: 根据具体失败项分析：

- **签名验证失败** → 检查产品公钥是否正确
- **设备不匹配** → Token来自其他设备（可能正常）
- **激活状态失败** → 需要重新激活
- **记账失败** → 检查Token权限或状态

### Q5: 多久应该执行一次验证？

**A**: 建议：
- **信任链验证**：每周一次（安全审计）
- **综合验证**：
  - 开发环境：每次构建后
  - 生产环境：每月一次或遇到问题时

### Q6: 验证结果如何保存？

**A**: 当前版本输出到终端。建议：
```bash
./validation_wizard > validation_report.txt 2>&1
```

---

## 总结

| 功能 | 简述 | 适用场景 |
|------|------|---------|
| **信任链验证** | 验证签名链完整性 | 安全审计、防篡改检查 |
| **综合验证** | 全面功能测试 | 集成测试、故障排查 |

两个功能互补，共同确保DecentriLicense系统的**安全性**和**可靠性**。
